name: Deploy to GCP VM
run-name: "${{ github.event_name == 'workflow_dispatch' && 'Manual deploy' || format('Deploy: {0}', github.event.head_commit.message) }}"

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      zone:
        description: 'GCP zone where the instance is located'
        required: false
        default: 'us-central1-a'

permissions:
  contents: read
  id-token: write
  packages: write

env:
  REGISTRY: ghcr.io
  INSTANCE_NAME: manifold-01

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: prod

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch secrets
        id: secrets
        uses: ./.github/actions/fetch-secrets
        with:
          doppler_token: ${{ secrets.DOPPLER_TOKEN_PROD }}

      - name: Setup domains
        id: domains
        uses: ./.github/actions/setup-domains
        with:
          base_domain: ${{ steps.secrets.outputs.BASE_DOMAIN }}

      - name: Authenticate to GCP via WIF
        uses: google-github-actions/auth@v2
        with:
          token_format: access_token
          workload_identity_provider: projects/${{ steps.secrets.outputs.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: manifold-provisioner@${{ steps.secrets.outputs.GCP_PROJECT_ID }}.iam.gserviceaccount.com

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract build-time secrets
        id: build_secrets
        env:
          SECRETS_FILE: ${{ steps.secrets.outputs.secrets_file }}
        run: |
          extract() {
            local key=$1
            local val=$(jq -r ".${key} // empty" "$SECRETS_FILE")
            echo "::add-mask::$val"
            echo "${key}=${val}" >> $GITHUB_OUTPUT
          }
          extract SUPABASE_ANON_KEY
          extract FIREBASE_API_KEY
          extract FIREBASE_AUTH_DOMAIN
          extract FIREBASE_PROJECT_ID
          extract FIREBASE_STORAGE_BUCKET
          extract FIREBASE_MESSAGING_SENDER_ID
          extract FIREBASE_APP_ID
          extract API_ENDPOINT

      - name: Build and push manifold-api image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: manifold-api.Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/manifold-api:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/manifold-api:latest
          cache-from: type=gha,scope=manifold-api
          cache-to: type=gha,mode=max,scope=manifold-api

      - name: Build and push manifold-web image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: manifold-web.Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/manifold-web:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/manifold-web:latest
          build-args: |
            DOMAIN=${{ steps.domains.outputs.main_domain }}
            FIREBASE_API_KEY=${{ steps.build_secrets.outputs.FIREBASE_API_KEY }}
            FIREBASE_AUTH_DOMAIN=${{ steps.build_secrets.outputs.FIREBASE_AUTH_DOMAIN }}
            FIREBASE_PROJECT_ID=${{ steps.build_secrets.outputs.FIREBASE_PROJECT_ID }}
            FIREBASE_STORAGE_BUCKET=${{ steps.build_secrets.outputs.FIREBASE_STORAGE_BUCKET }}
            FIREBASE_MESSAGING_SENDER_ID=${{ steps.build_secrets.outputs.FIREBASE_MESSAGING_SENDER_ID }}
            FIREBASE_APP_ID=${{ steps.build_secrets.outputs.FIREBASE_APP_ID }}
            API_ENDPOINT=${{ steps.build_secrets.outputs.API_ENDPOINT }}
            NEXT_PUBLIC_API_URL=${{ steps.domains.outputs.api_domain }}
            NEXT_PUBLIC_FIREBASE_ENV=DEV
            NEXT_PUBLIC_SUPABASE_URL=https://${{ steps.domains.outputs.db_domain }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ steps.build_secrets.outputs.SUPABASE_ANON_KEY }}
          cache-from: type=gha,scope=manifold-web
          cache-to: type=gha,mode=max,scope=manifold-web

      - name: Configure gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ steps.secrets.outputs.GCP_PROJECT_ID }}
          install_components: 'beta'

      - name: Verify target instance exists
        id: instance
        run: |
          ZONE="${{ github.event.inputs.zone || 'us-central1-a' }}"

          if ! gcloud compute instances describe "${{ env.INSTANCE_NAME }}" --zone="$ZONE" &>/dev/null; then
            echo "ERROR: Instance ${{ env.INSTANCE_NAME }} not found in zone $ZONE!"
            echo "Run provision-server.yml first."
            exit 1
          fi
          echo "Deploying to: ${{ env.INSTANCE_NAME }} in zone $ZONE"

          # Get instance's external IP for DNS
          STATIC_IP=$(gcloud compute instances describe "${{ env.INSTANCE_NAME }}" --zone="$ZONE" --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "static_ip=$STATIC_IP" >> $GITHUB_OUTPUT
          echo "Instance IP: $STATIC_IP"

      - name: Ensure DNS records exist
        uses: ./.github/actions/ensure-dns
        with:
          dns_names: ${{ steps.domains.outputs.dns_names }}
          base_domain: ${{ steps.secrets.outputs.BASE_DOMAIN }}
          static_ip: ${{ steps.instance.outputs.static_ip }}
          cloudflare_zone_id: ${{ steps.secrets.outputs.CLOUDFLARE_ZONE_ID }}
          cloudflare_api_token: ${{ steps.secrets.outputs.CLOUDFLARE_API_TOKEN }}

      - name: Upload repo files to VM
        run: |
          ZONE="${{ github.event.inputs.zone || 'us-central1-a' }}"

          # Create a tarball of needed files
          tar czf /tmp/manifold-deploy.tar.gz \
            docker-compose.yml \
            docker-compose.prod.yml \
            nginx.conf.template \
            volumes/

          gcloud beta compute scp /tmp/manifold-deploy.tar.gz \
            ${{ env.INSTANCE_NAME }}:/opt/manifold/deploy.tar.gz \
            --zone "$ZONE" \
            --tunnel-through-iap

          gcloud beta compute ssh ${{ env.INSTANCE_NAME }} \
            --zone "$ZONE" \
            --tunnel-through-iap \
            --command "
              cd /opt/manifold
              sudo tar xzf deploy.tar.gz
              rm deploy.tar.gz
            "

      - name: Deploy
        env:
          SECRETS_FILE: ${{ steps.secrets.outputs.secrets_file }}
        run: |
          ZONE="${{ github.event.inputs.zone || 'us-central1-a' }}"

          # Prepare secrets as base64 env file for safe SSH transfer
          SECRETS_ENV=$(jq -r 'del(.CLOUDFLARE_ORIGIN_CERT, .CLOUDFLARE_ORIGIN_KEY) | to_entries[] | "\(.key)=\(.value)"' "$SECRETS_FILE" | base64 -w0)

          gcloud beta compute ssh ${{ env.INSTANCE_NAME }} \
            --zone "$ZONE" \
            --tunnel-through-iap \
            --command "
              set -euo pipefail
              cd /opt/manifold

              # Login to GitHub Container Registry
              echo '${{ secrets.GITHUB_TOKEN }}' | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin

              # Pull the latest images
              sudo docker pull ghcr.io/${{ github.repository_owner }}/manifold-api:latest
              sudo docker pull ghcr.io/${{ github.repository_owner }}/manifold-web:latest

              # Clean up old images (keep last 24h)
              sudo docker image prune -a -f --filter 'until=24h' || true

              # Generate nginx.conf from template with domain substitution
              export MAIN_DOMAIN='${{ steps.domains.outputs.main_domain }}'
              export API_DOMAIN='${{ steps.domains.outputs.api_domain }}'
              export DB_DOMAIN='${{ steps.domains.outputs.db_domain }}'
              export STUDIO_DOMAIN='${{ steps.domains.outputs.studio_domain }}'
              envsubst '\${MAIN_DOMAIN} \${API_DOMAIN} \${DB_DOMAIN} \${STUDIO_DOMAIN}' < nginx.conf.template | sudo tee nginx.conf > /dev/null

              # Write Cloudflare Origin CA certificate for nginx SSL
              sudo mkdir -p /opt/manifold/ssl
              echo '${{ steps.secrets.outputs.CLOUDFLARE_ORIGIN_CERT }}' | sudo tee /opt/manifold/ssl/cert.pem > /dev/null
              echo '${{ steps.secrets.outputs.CLOUDFLARE_ORIGIN_KEY }}' | sudo tee /opt/manifold/ssl/key.pem > /dev/null
              sudo chmod 600 /opt/manifold/ssl/key.pem

              # Write env file from Doppler secrets
              echo '$SECRETS_ENV' | base64 -d | sudo tee .env > /dev/null

              COMPOSE_FILES='-f docker-compose.yml -f docker-compose.prod.yml'

              # Rolling restart: database first, then dependents
              echo 'Starting db...'
              sudo docker compose \$COMPOSE_FILES up -d db
              echo 'Waiting for db to be healthy...'
              for i in {1..30}; do
                if sudo docker inspect manifold-db --format='{{.State.Health.Status}}' 2>/dev/null | grep -q healthy; then
                  echo 'DB is healthy'
                  break
                fi
                echo \"Waiting for db health check... (\$i/30)\"
                sleep 5
              done

              echo 'Starting kong...'
              sudo docker compose \$COMPOSE_FILES up -d kong

              echo 'Starting auth...'
              sudo docker compose \$COMPOSE_FILES up -d auth

              echo 'Starting rest...'
              sudo docker compose \$COMPOSE_FILES up -d rest

              echo 'Starting meta...'
              sudo docker compose \$COMPOSE_FILES up -d meta

              echo 'Starting studio...'
              sudo docker compose \$COMPOSE_FILES up -d studio

              echo 'Starting manifold-api...'
              sudo docker compose \$COMPOSE_FILES up -d manifold-api

              echo 'Starting manifold-web...'
              sudo docker compose \$COMPOSE_FILES up -d manifold-web

              echo 'Starting manifold-scheduler...'
              sudo docker compose \$COMPOSE_FILES up -d manifold-scheduler

              # Restart nginx (force-recreate to pick up config changes)
              echo 'Restarting nginx...'
              sudo docker compose \$COMPOSE_FILES up -d --force-recreate nginx

              echo 'Deploy complete.'
              sudo docker ps
            "

      - name: Print summary
        run: |
          echo "## Deploy Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Instance:** ${{ env.INSTANCE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### URLs" >> $GITHUB_STEP_SUMMARY
          echo "- **Web:** https://${{ steps.domains.outputs.main_domain }}" >> $GITHUB_STEP_SUMMARY
          echo "- **API:** https://${{ steps.domains.outputs.api_domain }}/v0/markets" >> $GITHUB_STEP_SUMMARY
          echo "- **Studio:** https://${{ steps.domains.outputs.studio_domain }}" >> $GITHUB_STEP_SUMMARY
